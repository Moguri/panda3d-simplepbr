{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A straight-forward, easy-to-use PBR render pipeline for Panda3D. This project aims to be a drop-in replacement for Panda3D's auto-shader.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Supports running on a wide range of hardware with an easy OpenGL 2.1+ requirement</li> <li>Forward rendered metal-rough PBR</li> <li>All Panda3D light types (point, directional, spot, and ambient)</li> <li>Filmic tonemapping </li> <li>Normal maps</li> <li>Emission maps</li> <li>Occlusion maps</li> <li>Basic shadow mapping for DirectionalLight and Spotlight</li> <li>Post-tonemapping color transform via a lookup table (LUT) texture</li> <li>IBL diffuse and specular</li> </ul>"},{"location":"config/","title":"Configuration","text":"<p><code>simplepbr</code> is highly configurable, but attempts to use good, sensible defaults. The options below can be set via keyword arguments to <code>simplepbr.init()</code> They can also be changed later by modifying attributes of the same name on the <code>Pipeline</code> object returned by <code>simplepbr.init()</code>. For example:</p> <pre><code>pipeline = simplepbr.init(\n   enable_shadows=False,\n   max_lights=4,\n)\n\npipeline.max_lights = 6\npipeline.msaa_samples = 8\n</code></pre> <p>These options can also be set via PRC variables prior to initializing the <code>Pipeline</code> object (i.e., before calling <code>simplepbr.init()</code>. Change the PRC variables after the <code>Pipeline</code> object has been initialized will have no effect. The PRC variables use the same names as the options below except for:</p> <ul> <li>They start with <code>simplepbr-</code></li> <li>All hyphens (<code>-</code>) are replaced with underscores (<code>_</code>)</li> </ul> <p>For example, to set <code>max_lights</code> via a PRC variable:</p> <pre><code>simplepbr-max-lights 8\n</code></pre>"},{"location":"config/#pipeline-options","title":"Pipeline Options","text":""},{"location":"config/#setup","title":"Setup","text":"<code>render_node</code> The node to attach the shader too, defaults to <code>base.render</code> if <code>None</code> <code>window</code> The window to attach the framebuffer too, defaults to <code>base.win</code> if <code>None</code> <code>camera_node</code> The NodePath of the camera to use when rendering the scene, defaults to <code>base.cam</code> if <code>None</code> <code>msaa_samples</code> The number of samples to use for multisample anti-aliasing, defaults to 4 <code>use_330</code> Force shaders to use GLSL version 330 (if <code>True</code>) or 120 (if <code>False</code>) or auto-detect if <code>None</code>, defaults to <code>None</code> <code>use_hardware_skinning</code> Force usage of hardware skinning for skeleton animations or auto-detect if <code>None</code>, defaults to <code>None</code>"},{"location":"config/#lighting-and-shadows","title":"Lighting and Shadows","text":"<code>max_lights</code> The maximum number of lights to render, defaults to 8 <code>enable_shadows</code> Enable shadow map support, defaults to <code>True</code> <code>shadow_bias</code> A global bias for shadow mapping (increase to reduce shadow acne, decrease to reduce peter-panning), defaults to <code>0.005</code> <code>exposure</code> adjust the brightness of the scene prior to tonemapping (values greater than <code>0.0</code> brighten the scene and values less than <code>0.0</code> darken it), defaults to <code>0.0</code> <code>enable_fog</code> Enable exponential fog, defaults to False <code>env_map</code> An <code>EnvMap</code> or cubemap texture path to use for IBL, defaults to <code>None</code>"},{"location":"config/#textures","title":"Textures","text":"<code>use_normal_maps</code> Use normal maps to modify fragment normals, defaults to <code>False</code> (NOTE: Requires models with appropriate tangents defined) <code>calculate_normalmap_blue</code> Calculate the blue channel (Z-axis) for a normal map in the shader (allows saving memory/bandwidth by using 2 channel normal maps), defaults to <code>True</code> <code>use_emission_maps</code> Use emission maps, defaults to <code>True</code> <code>use_occlusion_maps</code> Use occlusion maps, defaults to <code>False</code> (NOTE: Requires occlusion channel in metal-roughness map)"},{"location":"config/#color-grading","title":"Color Grading","text":"<code>sdr_lut</code> Color LUT to use post-tonemapping <code>sdr_lut_factor</code> Factor (from 0.0 to 1.0) for how much of the LUT color to mix in, defaults to 1.0"},{"location":"features/","title":"Features","text":""},{"location":"features/#skyboxes","title":"Skyboxes","text":"<p>While not the trickiest thing to setup with standard Panda3D APIs, skyboxes can still be a bit involved to get right. <code>simplepbr</code> provides a utility function to take out some of the guess-work and just get a skybox going:</p> <pre><code>from direct.showbase.ShowBase import ShowBase\n\nimport simplepbr\n\nclass App(ShowBase):\n    def __init__(self):\n        super().__init__()\n\n        simplepbr.init()\n\n        cubemap = self.loader.load_cube_map('cubemap_#.hdr')\n        self.skybox = simplepbr.utils.make_skybox(cubemap)\n        self.skybox.reparent_to(self.render)\n</code></pre>"},{"location":"features/#envmap-and-image-based-lighting","title":"EnvMap and Image-based Lighting","text":"<p>Imaged-based lighting (IBL) requires a <code>simplepbr.EnvMap</code>. These asynchronously pre-compute items necessary for IBL diffuse (spherical harmonics) and IBL specular lighting (pre-filtered environment map). <code>EnvMap</code> objects can also be saved to disk to avoid doing these calculations at runtime as they can be quite slow. Similar to Panda3D's <code>TexturePool</code>, <code>simplepbr</code> provides a <code>simplepbr.EnvPool</code> to automatically handle caching <code>EnvMap</code> objects. Below is an example of using <code>simplepbr.EnvPool</code> to load a <code>simplepbr.EnvMap</code> from cubemap files on disk:</p> <pre><code>from direct.showbase.ShowBase import ShowBase\n\nimport simplepbr\n\nclass App(ShowBase):\n    def __init__(self):\n        super().__init__()\n\n        env_map = simplepbr.EnvPool.ptr().load('cubemap_#.hdr')\n\n        simplepbr.init(\n            env_map,\n        )\n</code></pre> <p>To created <code>EnvMap</code> files offline, <code>simplepbr</code> ships with an <code>hdr2env</code> tool:</p> <pre><code>hdr2env cubemap_#.hdr cubemap.env\n</code></pre> <p>An <code>env</code> file can be loaded like cubemap images using: <pre><code>env_map = simplepbr.EnvPool.ptr().load('cubemap.env')\n</code></pre></p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>Use pip to install the <code>panda3d-simplepbr</code> package:</p> <pre><code>pip install panda3d-simplepbr\n</code></pre> <p>To grab the latest development build, use:</p> <pre><code>pip install git+https://github.com/Moguri/panda3d-simplepbr.git\n</code></pre>"},{"location":"getting-started/#usage","title":"Usage","text":"<p>Just add <code>simplepbr.init()</code> to your <code>ShowBase</code> instance:</p> <pre><code>from direct.showbase.ShowBase import ShowBase\n\nimport simplepbr\n\nclass App(ShowBase):\n    def __init__(self):\n        super().__init__()\n\n        simplepbr.init()\n</code></pre>"},{"location":"getting-started/#pbr-textures","title":"PBR Textures","text":"<p><code>simplepbr</code> expects the following textures are assigned to the following texture stages:</p> <ul> <li>BaseColor - Modulate</li> <li>MetalRoughness - Selector</li> <li>Normals - Normal</li> <li>Emission - Emission</li> </ul> <p>For best results, ensure your asset pipeline is generating PBR materials for Panda3D. For example, glTF files loaded with panda3d-gltf are known to work well. However, EGG files do not support PBR materials at the time of writing.</p>"},{"location":"getting-started/#tangents-and-normal-maps","title":"Tangents and Normal Maps","text":"<p>To use normal maps, <code>simplepbr</code> expects 4-component tangent values (with no bi-normal/bi-tangent), which matchesl glTF. Panda3D may also switch to 4-component tangents in the future. Unfortunately, this means that panda3d-gltf is the best option for getting vertex data that works with normal mapping in <code>simplepbr</code>.</p>"}]}